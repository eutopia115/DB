-- lab 6-1-1
SELECT DNAME, NUM_EE
FROM (
    SELECT DNO, COUNT(*) NUM_EE, AVG(SALARY) AVG_SAL
    FROM EMPLOYEE
    GROUP BY DNO
    ) EX INNER JOIN DEPARTMENT D  ON EX.DNO = D.DNUMBER
WHERE AVG_SAL >= 20000 AND AVG_SAL <= 40000
ORDER BY NUM_EE ASC;
-- ans :
-- Administration,3
-- Research,4

-- lab 6-1-2
SELECT DNUMBER, DNAME, MALES
FROM (
    SELECT DNO, COUNT(*) AS MALES
    FROM EMPLOYEE
    WHERE SEX = 'M' AND SALARY < 40000
    GROUP BY DNO
     ) A INNER JOIN DEPARTMENT D ON A.DNO = D.DNUMBER
ORDER BY DNAME DESC;
-- ans :
-- 5,Research,2
-- 4,Administration,1

-- lab 6-2-1
SELECT EX.FNAME, EX.LNAME, EX.SALARY
FROM EMPLOYEE EX
WHERE SEX = 'F' AND NOT EXISTS (
    SELECT 1
    FROM (
        SELECT W.ESSN, W.PNO
        FROM WORKS_ON W INNER JOIN (
            SELECT P.PNUMBER
            FROM PROJECT P
            WHERE P.DNUM != 4
        ) X ON W.PNO = X.PNUMBER
    ) NX
    WHERE NX.ESSN = EX.SSN
)
ORDER BY SALARY ASC;
-- ans :
-- Alica,Zelaya,25000

-- lab 6-2-2
SELECT E.DNO, E.FNAME, E.LNAME
FROM EMPLOYEE E INNER JOIN (
    SELECT DISTINCT X.SUPER_SSN
    FROM EMPLOYEE X
    WHERE SUPER_SSN IS NOT NULL AND NOT EXISTS(
        SELECT DP.ESSN
        FROM DEPENDENT DP
        WHERE X.SUPER_SSN = DP.ESSN
    )
) DX ON DX.SUPER_SSN = E.SSN;

-- ans :
-- 1,James,Borg


-- lab 6-3-1
SELECT LNAME, FNAME, SALARY
FROM EMPLOYEE
WHERE DNO IN (
    SELECT DNO
    FROM EMPLOYEE
    WHERE SALARY = (
        SELECT MAX(SALARY)
        FROM EMPLOYEE EA
    )
);
-- ans :
-- Borg,James,55000

-- lab 6-3-2
WITH RECURSIVE(SSN, SUPER_SSN) AS(
    SELECT E1.SSN, E1.SUPER_SSN
    FROM EMPLOYEE E1
    UNION ALL
    SELECT E2.SSN, RX.SUPER_SSN
    FROM EMPLOYEE E2, RECURSIVE RX
    WHERE E2.SUPER_SSN = RX.SSN AND RX.SUPER_SSN = '987654321'
)
SELECT FNAME, LNAME
FROM EMPLOYEE EX INNER JOIN (
    SELECT SSN, SUPER_SSN
    FROM RECURSIVE MINUS (
        SELECT SSN, SUPER_SSN
        FROM EMPLOYEE E
    )
) X ON X.SSN = EX.SSN;
-- ans : result does not exist
SELECT DNUMBER, DNAME, E.SEX, COUNT(*)
FROM DEPARTMENT, EMPLOYEE E
WHERE DNUMBER = DNO
AND DNO IN (
    SELECT DNO
    FROM EMPLOYEE
    GROUP BY DNO
    HAVING AVG(SALARY) < 40000)
GROUP BY ROLLUP (DNUMBER, DNAME, E.SEX);


-- lab 6-3-3
SELECT EX.FNAME, EX.LNAME, EX.ADDRESS, EX.SALARY
FROM EMPLOYEE EX
WHERE EX.SALARY >= (
    SELECT AVG(SALARY)
    FROM EMPLOYEE
    ) + 3000;
-- ans :
-- Franklin,Wong,"638 Voss, Houston, TX",40000
-- Jennifer,Wallace,"291 Berry, Bellaire, TX",43000
-- James,Borg,"450 Stone, Houston, TX",55000

-- lab 6-4-1
CREATE VIEW DEPT_SUMMARY (D, C, TOTAL_S, AVG_S, MN_S, MX_S) AS
    SELECT DNO, COUNT(*) AS NEMPS, SUM(SALARY), ROUND(AVG(SALARY), 1), MIN(SALARY), MAX(SALARY)
    FROM EMPLOYEE
    GROUP BY DNO
    ORDER BY NEMPS;
COMMIT;
SELECT *
FROM DEPT_SUMMARY;
-- ans :
-- 1,1,55000,55000,55000,55000
-- 4,3,93000,31000,25000,43000
-- 5,4,133000,33250,25000,40000

-- lab 6-4-2
SELECT *
FROM DEPT_SUMMARY
WHERE D = 5;
-- ans : 5,4,133000,33250,25000,40000

-- lab 6-4-3
SELECT D, C, AVG_S
FROM DEPT_SUMMARY
WHERE AVG_S BETWEEN 30000 AND 40000;
-- ans :
-- 4,3,31000
-- 5,4,33250

-- lab 6-4-4
SELECT D, AVG_S, MN_S, MX_S
FROM DEPT_SUMMARY
WHERE MN_S >= (
    SELECT AVG_S
    FROM DEPT_SUMMARY
    WHERE D = 5
    )
ORDER BY AVG_S DESC ;
-- ans : 1,55000,55000,55000

-- lab 6-4-5
/* UPDATE DEPT_SUMMARY
SET D=5
WHERE D=4;

SELECT *
FROM DEPT_SUMMARY;

ROLLBACK; */
-- ans : err. 뷰의 데이터를 직접 수정하는 것은 불가능하다. 테이블에서 참조만 해오기 때문

-- lab 6-4-6
/*DELETE FROM DEPT_SUMMARY
WHERE C BETWEEN 2 AND 4;

SELECT *
FROM DEPT_SUMMARY;

ROLLBACK; */
-- ANS : err. 뷰의 데이터를 직접 삭제하는 것은 불가능하다. 테이블에서 참조만 해오기 때문


CREATE OR REPLACE TRIGGER SALARY_VIOLATION
-- EVENT
BEFORE INSERT OR UPDATE ON EMPLOYEE
FOR EACH ROW
    -- CONDITION
BEGIN
    DBMS_OUTPUT.PUT('OLD SALARY : ');
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(:OLD.SALARY));
    DBMS_OUTPUT.PUT('[ALERT]NEW SALARY : ');
    DBMS_OUTPUT.PUT_LINE( TO_CHAR(:NEW.SALARY));
    DBMS_OUTPUT.PUT('SALARY DIFFERENCE = ');
    DBMS_OUTPUT.PUT_LINE( TO_CHAR(:NEW.SALARY - :OLD.SALARY));
    DBMS_OUTPUT.PUT_LINE('UPDATE EMPLOYEE');
    -- LOCAL에서 COMPANY 계정으로 해서 UNIVERSITY는 지웠습니다.
    IF :NEW.SALARY > 100000 THEN
        RAISE_APPLICATION_ERROR(-20111, 'THE NEW SALARY CANNOT EXCEED 100000');
    END IF;
END;

ALTER TRIGGER SALARY_VIOLATION ENABLE;

SET SERVEROUTPUT ON;

UPDATE EMPLOYEE SET SALARY = SALARY * 2 WHERE SSN = '888665555';

ROLLBACK ;

-- ans :
-- 트리거가 생성되었습니다.
-- SQL> ALTER TRIGGER SALARY_VIOLATION ENABLE;
-- 트리거가 변경되었습니다.
-- SQL> UPDATE EMPLOYEE SET SALARY = SALARY * 2 WHERE SSN = '888665555';
-- OLD SALARY : 55000
-- [ALERT]NEW SALARY : 110000
-- SALARY DIFFERENCE = 55000
-- UPDATE EMPLOYEE
-- UPDATE EMPLOYEE SET SALARY = SALARY * 2 WHERE SSN = '888665555'
--        *
-- 1행에 오류:
-- ORA-20111: THE NEW SALARY CANNOT EXCEED 100000
-- ORA-06512: "COMPANY.SALARY_VIOLATION",  11행
-- ORA-04088: 트리거 'COMPANY.SALARY_VIOLATION'의 수행시 오류